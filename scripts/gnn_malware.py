import os
import torch
import torch.nn.functional as F
from torch_geometric.data import DataLoader
from torch_geometric.nn import GCNConv, global_mean_pool

# Definizione del modello GNN
class GNNClassifier(torch.nn.Module):
    def __init__(self, hidden_channels):
        super(GNNClassifier, self).__init__()
        self.conv1 = GCNConv(in_channels=1, out_channels=hidden_channels)
        self.conv2 = GCNConv(in_channels=hidden_channels, out_channels=hidden_channels)
        self.linear = torch.nn.Linear(hidden_channels, 2)

    def forward(self, edge_index, batch):
        x = torch.ones((batch.size(0), 1), dtype=torch.float)
        x = self.conv1(x, edge_index)
        x = F.relu(x)
        x = self.conv2(x, edge_index)
        x = F.relu(x)
        x = global_mean_pool(x, batch)
        x = F.dropout(x, p=0.5, training=self.training)
        x = self.linear(x)
        return F.log_softmax(x, dim=1)


import os
import torch
from torch_geometric.data import Data, DataLoader

# Caricamento dei dati
class GraphDataset(torch.utils.data.Dataset):
    def __init__(self, root_dir):
        self.root_dir = root_dir
        self.graph_files = os.listdir(root_dir)

    def __len__(self):
        return len(self.graph_files)

    def __getitem__(self, idx):
        graph_file = os.path.join(self.root_dir, self.graph_files[idx])
        graph_data = torch.load(graph_file)

        # Verifica se edge_index è None
        if graph_data.edge_index is None:
            print(f"AVVISO: Il grafo nel file {graph_file} non contiene informazioni sugli archi. Questo file verrà ignorato.")
            return None  # Ignora questo file e passa al prossimo

        # Creazione dell'oggetto Data
        data = Data(edge_index=graph_data.edge_index, y=graph_data.y)

        return data

# Caricamento dei dati e creazione del DataLoader
dataset = GraphDataset(root_dir='E:\scritturaTesiMagistrale\grafi_pt')

# Rimuovi i dati None dalla lista
dataset = [data for data in dataset if data is not None]

loader = DataLoader(dataset, batch_size=32, shuffle=True)



# Inizializzazione del modello
model = GNNClassifier(hidden_channels=64)

# Definizione della funzione di perdita e dell'ottimizzatore
criterion = torch.nn.NLLLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.01)

# Addestramento del modello
model.train()
for epoch in range(100):
    for data in loader:
        optimizer.zero_grad()
        out = model(data[0], data[1])
        loss = criterion(out, data[1])
        loss.backward()
        optimizer.step()

# Valutazione del modello
model.eval()
correct = 0
total = 0
for data in loader:
    out = model(data[0], data[1])
    pred = out.max(dim=1)[1]
    correct += pred.eq(data[1]).sum().item()
    total += len(data[1])

accuracy = correct / total
print('Accuracy:', accuracy)




